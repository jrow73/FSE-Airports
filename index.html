<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FSE Airports Map</title>

  <!-- Leaflet CSS & JS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet.glify -->
  <script src="https://unpkg.com/leaflet.glify@3.0.0/dist/leaflet.glify.min.js"></script>

  <!-- Choices.js for enhanced dropdowns -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/choices.js/public/assets/styles/choices.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/choices.js/public/assets/scripts/choices.min.js"></script>

  <style>
    html, body { margin: 0; padding: 0; height: 100%; width: 100%; }
    #map { width: 100%; height: 100%; z-index: 1; }

    /* Toggle button */
    #filter-toggle {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #fff;
      border: 1px solid #ccc;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      z-index: 1001;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }

    /* Filter box */
    #filter-box {
      position: absolute;
      top: 50px;
      right: 10px;
      width: 260px;
      background: white;
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      font-family: sans-serif;
      font-size: 13px;
      z-index: 1000;
      max-height: 80%;
      overflow-y: auto;
      transition: transform 0.25s ease, opacity 0.25s ease;
    }

    #filter-box.hidden {
      transform: translateX(280px); /* slide off to the right */
      opacity: 0;
      pointer-events: none;
    }

    #filter-box h3 { margin-top: 0; text-align: center; }

    /* Runway inputs side-by-side */
    .runway-inputs {
      display: flex;
      gap: 4px;
    }
    .runway-inputs input {
      flex: 1;
      max-width: 100px;
    }

    .buttons {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      margin-top: 8px;
    }
    .buttons button {
      flex: 1;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      padding: 6px 0;
      font-weight: bold;
      color: white;
    }
    #applyFilters { background-color: #007bff; }
    #resetFilters { background-color: #6c757d; }

    .leaflet-popup-content { font-size: 13px; line-height: 1.4em; }

    /* Search toggle button */
  #search-toggle {
    position: absolute;
    top: 10px;
    right: 90px; /* offset from filter toggle */
    background: #fff;
    border: 1px solid #ccc;
    padding: 6px 10px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
    z-index: 1001;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  }

  /* Search box */
  #search-box {
    position: absolute;
    top: 50px;
    right: 90px;
    width: 260px;
    background: white;
    padding: 12px;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    font-family: sans-serif;
    font-size: 13px;
    z-index: 1000;
    max-height: 80%;
    overflow-y: auto;
    transition: transform 0.25s ease, opacity 0.25s ease;
  }
  #search-box.hidden {
    transform: translateX(280px);
    opacity: 0;
    pointer-events: none;
  }

  #search-box h3 { margin-top: 0; text-align: center; }
  #search-box input { width: 100%; margin-bottom: 6px; padding: 4px; }
  #search-box button { width: 100%; padding: 6px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; }
  #search-box button:hover { background: #1e7b32; }
  </style>
</head>

<body>
  <div id="map"></div>

  <!-- Collapsible Filter Box -->
  <div id="filter-toggle">‚ò∞ Filters</div>
  <div id="filter-box" class="hidden">
    <h3>Filter Airports</h3>

    <label>Type:</label>
    <select id="typeFilter" multiple>
      <option value="civil">Civil</option>
      <option value="water">Water</option>
      <option value="military">Military</option>
    </select>

    <label>Size:</label>
    <select id="sizeFilter" multiple>
      <option value="small">Small</option>
      <option value="medium">Medium</option>
      <option value="large">Large</option>
    </select>

    <label>Surface:</label>
    <select id="surfaceFilter" multiple></select>

    <label>Runway Length (ft):</label>
    <div class="runway-inputs">
      <input type="number" id="minRunway" placeholder="Min" />
      <input type="number" id="maxRunway" placeholder="Max" />
    </div>

    <div class="buttons">
      <button id="applyFilters">Apply</button>
      <button id="resetFilters">Reset</button>
    </div>
  </div>

  <div id="search-toggle">üîç Search</div>
<div id="search-box" class="hidden">
  <h3>Search Airports</h3>

  <label>ICAO:</label>
  <input type="text" id="icaoSearch" placeholder="e.g., KJFK" />

  <label>City:</label>
  <input type="text" id="citySearch" placeholder="e.g., New York" />

  <label>Lat, Lon:</label>
  <input type="text" id="latlonSearch" placeholder="e.g., 40.7128,-74.0060" />

  <button id="goSearch">Go</button>
</div>

  <script>
    // Toggle filter panel
    const filterBox = document.getElementById('filter-box');
    const toggleBtn = document.getElementById('filter-toggle');
    toggleBtn.addEventListener('click', () => filterBox.classList.toggle('hidden'));

    // Initialize Choices.js dropdowns
    const typeChoices = new Choices('#typeFilter', { removeItemButton: true });
    const sizeChoices = new Choices('#sizeFilter', { removeItemButton: true });
    const surfaceChoices = new Choices('#surfaceFilter', { removeItemButton: true });

    // === MAP INITIALIZATION ===
    const map = L.map('map').setView([20, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

    const typeColor = { civil: '#2ca02c', water: '#1f77b4', military: '#d62728' };
    function getRadius(size) {
      if (size < 1000) return 3;
      if (size < 3500) return 6;
      return 9;
    }

    fetch('https://raw.githubusercontent.com/jrow73/FSE-Airports/main/airports.geojson')
      .then(res => res.json())
      .then(geojson => {
        const allFeatures = geojson.features;

        // Populate surface filter dynamically
        const uniqueSurfaces = [...new Set(allFeatures.map(f => f.properties.surfaceType).filter(Boolean))].sort();
        surfaceChoices.clearStore();
        uniqueSurfaces.forEach(s => surfaceChoices.setChoices([{ value: s, label: s }], 'value', 'label', false));

        let layerGroup = L.layerGroup().addTo(map);

        function renderFeatures(features) {
          layerGroup.clearLayers();
          features.forEach(f => {
            const p = f.properties;
            const circle = L.circleMarker([f.geometry.coordinates[1], f.geometry.coordinates[0]], {
              radius: getRadius(p.size),
              fillColor: typeColor[p.type] || '#888',
              color: '#000',
              weight: 0.5,
              fillOpacity: 0.8
            });
            const popupHtml = `
              <strong>${p.name || 'Unknown'}</strong><br/>
              ${p.city || ''}, ${p.state || ''}<br/>
              Type: ${p.type}<br/>
              Size: ${p.size}<br/>
              Elev: ${p.elev} ft<br/>
              Runway: ${p.longestRwy} ft<br/>
              Surface: ${p.surfaceType}<br/>
              Services: ${p.services}
            `;
            circle.bindPopup(popupHtml);
            layerGroup.addLayer(circle);
          });
        }

        renderFeatures(allFeatures);

        document.getElementById('applyFilters').addEventListener('click', () => {
          const selectedTypes = typeChoices.getValue(true);
          const selectedSizes = sizeChoices.getValue(true);
          const selectedSurfaces = surfaceChoices.getValue(true);
          const minRwy = parseFloat(document.getElementById('minRunway').value) || 0;
          const maxRwy = parseFloat(document.getElementById('maxRunway').value) || Infinity;

          const filtered = allFeatures.filter(f => {
            const p = f.properties;
            if (selectedTypes.length && !selectedTypes.includes(p.type)) return false;
            if (selectedSurfaces.length && !selectedSurfaces.includes(p.surfaceType)) return false;
            if (selectedSizes.length) {
              const cat = p.size < 1000 ? 'small' : p.size < 3500 ? 'medium' : 'large';
              if (!selectedSizes.includes(cat)) return false;
            }
            if (p.longestRwy < minRwy || p.longestRwy > maxRwy) return false;
            return true;
          });

          renderFeatures(filtered);
        });

        document.getElementById('resetFilters').addEventListener('click', () => {
          typeChoices.removeActiveItems();
          sizeChoices.removeActiveItems();
          surfaceChoices.removeActiveItems();
          document.getElementById('minRunway').value = '';
          document.getElementById('maxRunway').value = '';
          renderFeatures(allFeatures);
        });
      })
      .catch(err => console.error('Error loading GeoJSON:', err));

  // Toggle search panel
  const searchBox = document.getElementById('search-box');
  const searchToggle = document.getElementById('search-toggle');
  searchToggle.addEventListener('click', () => searchBox.classList.toggle('hidden'));

  // Go button logic
  document.getElementById('goSearch').addEventListener('click', () => {
    const icaoVal = document.getElementById('icaoSearch').value.trim().toLowerCase();
    const cityVal = document.getElementById('citySearch').value.trim().toLowerCase();
    const latlonVal = document.getElementById('latlonSearch').value.trim();

    let targetLatLng = null;

    // 1Ô∏è‚É£ Search by ICAO or City
    if ((icaoVal || cityVal) && typeof allFeatures !== 'undefined') {
      const found = allFeatures.find(f => {
        const p = f.properties;
        const matchesICAO = icaoVal && p.icao?.toLowerCase() === icaoVal;
        const matchesCity = cityVal && p.city?.toLowerCase().includes(cityVal);
        return matchesICAO || matchesCity;
      });
      if (found) {
        targetLatLng = [found.geometry.coordinates[1], found.geometry.coordinates[0]];
      }
    }

    // 2Ô∏è‚É£ Search by Lat,Lon input
    if (!targetLatLng && latlonVal) {
      const parts = latlonVal.split(',');
      if (parts.length === 2) {
        const lat = parseFloat(parts[0]);
        const lon = parseFloat(parts[1]);
        if (!isNaN(lat) && !isNaN(lon)) {
          targetLatLng = [lat, lon];
        }
      }
    }

    if (targetLatLng) {
      map.setView(targetLatLng, 10); // Zoom in to found location
      // Optionally open popup if matching feature
      const feature = allFeatures?.find(f =>
        f.geometry.coordinates[1] === targetLatLng[0] &&
        f.geometry.coordinates[0] === targetLatLng[1]
      );
      if (feature) {
        L.popup()
          .setLatLng(targetLatLng)
          .setContent(`<strong>${feature.properties.name}</strong><br/>${feature.properties.city || ''}`)
          .openOn(map);
      }
    } else {
      alert('No matching location found.');
    }
  });
    
  </script>
</body>
</html>
